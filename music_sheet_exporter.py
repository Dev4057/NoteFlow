"""
Music Sheet Exporter Module
Exports recordings to professional two-column music notation format
"""

import logging
import os
from datetime import datetime
from typing import List, Dict, Optional

from docx import Document
from docx.shared import Inches, Pt, RGBColor
from docx.enum.text import WD_PARAGRAPH_ALIGNMENT
from docx.oxml.ns import qn
from docx.oxml import OxmlElement


class MusicSheetExporter:
    """Exports recordings to two-column music sheet format"""
    
    def __init__(self):
        """Initialize the exporter"""
        pass
    
    def export_to_music_sheet(
        self,
        events: List[Dict],
        filepath: str,
        options: Optional[Dict] = None
    ) -> bool:
        """
        Export recording to two-column music sheet format.
        
        Args:
            events: List of recorded events (chords and notes)
            filepath: Path to save the .docx file
            options: Export options dictionary
            
        Returns:
            True if successful, False otherwise
        """
        logging.info("export_to_music_sheet called for %s", filepath)
        
        # Default options
        if options is None:
            options = {}
        
        title = options.get('title', 'Recording')
        measures_per_line = options.get('measures_per_line', 4)
        include_chords = options.get('include_chords', True)
        include_melody = options.get('include_melody', True)
        detect_sections = options.get('detect_sections', True)
        pause_threshold = options.get('pause_threshold', 2.0)
        
        try:
            # Ensure the directory exists
            directory = os.path.dirname(filepath)
            if directory and not os.path.exists(directory):
                logging.info("Creating directory %s", directory)
                os.makedirs(directory)
            
            # Detect sections if enabled
            if detect_sections:
                sections = self._detect_sections(events, pause_threshold)
            else:
                sections = [events] if events else []
            
            # Create document
            doc = Document()
            logging.info("Document object created")
            
            # Set margins
            for section in doc.sections:
                section.left_margin = Inches(0.5)
                section.right_margin = Inches(0.5)
                section.top_margin = Inches(0.75)
                section.bottom_margin = Inches(0.75)
            
            # Add title
            title_para = doc.add_heading(title, 0)
            title_para.alignment = WD_PARAGRAPH_ALIGNMENT.CENTER
            
            # Add subtitle with date
            date_para = doc.add_paragraph()
            date_run = date_para.add_run(datetime.now().strftime('%B %d, %Y'))
            date_run.font.size = Pt(12)
            date_run.font.italic = True
            date_para.alignment = WD_PARAGRAPH_ALIGNMENT.CENTER
            
            doc.add_paragraph()  # Spacing
            
            # Create two-column layout table
            main_table = doc.add_table(rows=1, cols=2)
            main_table.autofit = False
            main_table.allow_autofit = False
            
            # Set column widths (50/50 split)
            for row in main_table.rows:
                row.cells[0].width = Inches(3.5)
                row.cells[1].width = Inches(3.5)
            
            left_cell = main_table.rows[0].cells[0]
            right_cell = main_table.rows[0].cells[1]
            
            # Build content
            if include_chords:
                self._build_chord_progressions(left_cell, sections, measures_per_line)
            else:
                left_para = left_cell.paragraphs[0]
                left_para.add_run("Chord progressions not included")
                left_para.alignment = WD_PARAGRAPH_ALIGNMENT.CENTER
            
            if include_melody:
                self._build_melody_sequences(right_cell, sections)
            else:
                right_para = right_cell.paragraphs[0]
                right_para.add_run("Melody sequences not included")
                right_para.alignment = WD_PARAGRAPH_ALIGNMENT.CENTER
            
            # Add footer
            doc.add_paragraph()
            footer = doc.add_paragraph()
            footer_run = footer.add_run('\nGenerated by NoteFlow - MIDI Note Recorder')
            footer_run.italic = True
            footer_run.font.size = Pt(9)
            footer.alignment = WD_PARAGRAPH_ALIGNMENT.CENTER
            
            # Save document
            doc.save(filepath)
            logging.info("Music sheet saved to %s", filepath)
            return True
            
        except PermissionError:
            logging.exception("Permission denied writing %s", filepath)
            return False
        except Exception:
            logging.exception("Error exporting music sheet to %s", filepath)
            return False
    
    def _detect_sections(self, events: List[Dict], pause_threshold: float) -> List[List[Dict]]:
        """
        Detect sections based on pauses between events.
        
        Args:
            events: List of events
            pause_threshold: Minimum pause duration in seconds
            
        Returns:
            List of sections
        """
        if not events:
            return []
        
        sections = []
        current_section = []
        last_time = None
        
        for event in events:
            event_time = event.get('relative_time', 0)
            
            if last_time is not None:
                pause_duration = event_time - last_time
                
                if pause_duration > pause_threshold:
                    # Start new section
                    if current_section:
                        sections.append(current_section)
                    current_section = []
            
            current_section.append(event)
            last_time = event_time
        
        # Add the last section
        if current_section:
            sections.append(current_section)
        
        return sections
    
    def _build_chord_progressions(
        self,
        cell,
        sections: List[List[Dict]],
        measures_per_line: int
    ):
        """
        Build chord progression tables in the left column.
        
        Args:
            cell: Table cell to populate
            sections: List of sections
            measures_per_line: Number of measures per table row
        """
        # Clear default paragraph
        if cell.paragraphs:
            cell.paragraphs[0].text = ''
        
        # Add heading
        heading = cell.add_paragraph()
        heading_run = heading.add_run('CHORD PROGRESSIONS')
        heading_run.bold = True
        heading_run.font.size = Pt(12)
        heading.alignment = WD_PARAGRAPH_ALIGNMENT.CENTER
        
        cell.add_paragraph()  # Spacing
        
        # Build a table for each section
        for section_num, section in enumerate(sections, 1):
            # Extract chords from this section
            chords = [e for e in section if e.get('type') == 'chord']
            
            if not chords:
                # No chords in this section
                section_para = cell.add_paragraph()
                section_run = section_para.add_run(f'Section {section_num}: (no chords)')
                section_run.italic = True
                section_run.font.size = Pt(10)
                cell.add_paragraph()
                continue
            
            # Section label
            label_para = cell.add_paragraph()
            label_run = label_para.add_run(f'Section {section_num}:')
            label_run.bold = True
            label_run.font.size = Pt(11)
            
            # Create chord table
            num_chords = len(chords)
            num_cols = min(measures_per_line, num_chords)
            
            # Create table with header + 1 data row
            chord_table = cell.add_table(rows=2, cols=num_cols)
            chord_table.style = 'Light Grid Accent 1'
            
            # Header row - measure numbers
            for i in range(num_cols):
                header_cell = chord_table.rows[0].cells[i]
                header_para = header_cell.paragraphs[0]
                header_para.add_run(str(i + 1)).bold = True
                header_para.alignment = WD_PARAGRAPH_ALIGNMENT.CENTER
            
            # Data row - chord names
            for i in range(num_cols):
                if i < len(chords):
                    chord = chords[i]
                    data_cell = chord_table.rows[1].cells[i]
                    data_para = data_cell.paragraphs[0]
                    data_run = data_para.add_run(chord.get('display_name', ''))
                    data_run.font.size = Pt(11)
                    data_para.alignment = WD_PARAGRAPH_ALIGNMENT.CENTER
            
            # If there are more chords, create additional rows
            remaining_chords = chords[num_cols:]
            while remaining_chords:
                cell.add_paragraph()  # Small spacing
                
                batch = remaining_chords[:num_cols]
                remaining_chords = remaining_chords[num_cols:]
                
                # Create continuation table
                cont_table = cell.add_table(rows=2, cols=len(batch))
                cont_table.style = 'Light Grid Accent 1'
                
                # Header row
                for i in range(len(batch)):
                    header_cell = cont_table.rows[0].cells[i]
                    header_para = header_cell.paragraphs[0]
                    # Calculate measure number for continuation tables
                    # Start after first table, add chords processed so far
                    chords_processed = len(chords) - len(remaining_chords) - len(batch)
                    measure_num = num_cols + chords_processed + i + 1
                    header_para.add_run(str(measure_num)).bold = True
                    header_para.alignment = WD_PARAGRAPH_ALIGNMENT.CENTER
                
                # Data row
                for i, chord in enumerate(batch):
                    data_cell = cont_table.rows[1].cells[i]
                    data_para = data_cell.paragraphs[0]
                    data_run = data_para.add_run(chord.get('display_name', ''))
                    data_run.font.size = Pt(11)
                    data_para.alignment = WD_PARAGRAPH_ALIGNMENT.CENTER
            
            cell.add_paragraph()  # Spacing between sections
    
    def _build_melody_sequences(self, cell, sections: List[List[Dict]]):
        """
        Build melody note sequences in the right column.
        
        Args:
            cell: Table cell to populate
            sections: List of sections
        """
        # Clear default paragraph
        if cell.paragraphs:
            cell.paragraphs[0].text = ''
        
        # Add heading
        heading = cell.add_paragraph()
        heading_run = heading.add_run('MELODY SEQUENCES')
        heading_run.bold = True
        heading_run.font.size = Pt(12)
        heading.alignment = WD_PARAGRAPH_ALIGNMENT.CENTER
        
        cell.add_paragraph()  # Spacing
        
        # Build sequences for each section
        for section_num, section in enumerate(sections, 1):
            # Extract all notes from events in this section
            notes = []
            for event in section:
                event_type = event.get('type', 'note')
                if event_type == 'note':
                    notes.append(event.get('display_name', ''))
                elif event_type == 'chord':
                    # For chords, include the individual notes
                    chord_notes = event.get('notes', [])
                    if chord_notes:
                        # Just use the chord display name in brackets
                        notes.append(f"[{event.get('display_name', '')}]")
                elif event_type == 'interval':
                    # For intervals, show both notes
                    interval_notes = event.get('notes', [])
                    if interval_notes:
                        notes.append('+'.join(interval_notes))
            
            if not notes:
                continue
            
            # Section label
            label_para = cell.add_paragraph()
            label_run = label_para.add_run(f'Sequence {section_num}:')
            label_run.bold = True
            label_run.font.size = Pt(11)
            
            # Melody sequence
            sequence_text = ' â†’ '.join(notes)
            sequence_para = cell.add_paragraph()
            sequence_run = sequence_para.add_run(sequence_text)
            sequence_run.font.size = Pt(10)
            
            cell.add_paragraph()  # Spacing
